/**
 * 
 */
package pacman.entries.jcgrPacMan.EA;

import pacman.controllers.Controller;
import pacman.entries.jcgrPacMan.DataRecording.JcgrDataTuple;
import pacman.entries.jcgrPacMan.NN.NeuralNetwork;
import pacman.game.Game;
import pacman.game.Constants.MOVE;

/**
 * A controller for running trials for the evolutionary algorithm.
 *
 * To see a visual playout of the NN generated by EA, use the NNPacMan controller.
 * 
 * @author Jacob
 */
public class EvolutionTestController extends Controller<MOVE>
{
	/**
	 * The number of input nodes.
	 */
	int numberOfInputs;
	
	/**
	 * The number of output nodes.
	 */
	int numberOfOutputs;
	
	/**
	 * The number of nodes in the hidden layer.
	 */
	int hiddenLayerNeurons;
	
	/**
	 * The neural network used by the controller.
	 */
	NeuralNetwork nn;

	public EvolutionTestController(NeuralNetwork neuralNetwork, int inputNodes, int hiddenLayerNodes, int outputNodes)
	{
		nn = neuralNetwork;

		this.numberOfInputs = inputNodes;
		this.hiddenLayerNeurons = hiddenLayerNodes;
		this.numberOfOutputs = outputNodes;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see pacman.controllers.Controller#getMove(pacman.game.Game, long)
	 */
	public MOVE getMove(Game game, long timeDue)
	{
		// Get data based on the game.
		JcgrDataTuple dt = new JcgrDataTuple(game, lastMove);

		// Converts the data tuple to an input array.
		double[] input = new double[numberOfInputs];
		input[0] = dt.normalizeDistance(dt.nearestPillDistance);
		input[1] = dt.moveToDouble(dt.nearestPillDirection);
		input[2] = dt.normalizeDistance(dt.nearestGhostDistance);
		input[3] = dt.moveToDouble(dt.nearestGhostDirection);

		// Runs the neural network
		nn.setInputs(input);
		nn.activate();

		// Gets the output and converts it to a MOVE value.
		double[] output = nn.getOutput();
		double finalOutput = -50000;
		MOVE chosenMove = MOVE.NEUTRAL;
		
		for (int i = 0; i < output.length; i++)
		{
			if (output[i] > finalOutput)
			{
				finalOutput = output[i];
				switch (i)
				{
				case 0:
					chosenMove = MOVE.UP;
					break;
				case 1:
					chosenMove = MOVE.RIGHT;
					break;
				case 2:
					chosenMove = MOVE.DOWN;
					break;
				case 3:
					chosenMove = MOVE.LEFT;
					break;
				case 4:
					chosenMove = MOVE.NEUTRAL;
					break;
				}
			}
		}
		
		return chosenMove;
	}

}
